# Python_Hub_Studio
# Python_7_Hours

# КОДИРОВКА ФАЙЛОВ.

# Синтаксис.

# "r"" - открыть для чтения
# "t" - открыть в текстовом режиме (по умолчанию)
# "w" - открыть для записи, содержимое файла удаляется. Если файла нет, создается новый
# "a" - открыть для дозаписи в конец файла. Если файла нет, создается новый
# "b"" - открыть в бинарном режиме
# "+" - откртыть для чтения и записи "r", "w", "a"

# Создадим файл по указанному пути и дополним его информацией. Если по указанному
# пути такой файл есть, старый файл удалится и создастся новый (поскольку "w").

r = open("path_to_file\\New_file1.txt", "w") # записать "w"
r.write("Данные дополнены") # записать информацию
r.close() # закрыть файл

# Прочитаем информацию из созданного файла.

r = open("path_to_file\\New_file1.txt")
information = r.read() # прочитанные данне сохраняются в переменной
print(information) # вывод информации на экран
input() # пауза
r.close() # закрыть файл

# Спарсить указанный путь и записать в текстовый файл пути к каждому файлу.
import os


path = "your_directory_path\\Dir_name" # directory_path
list_paths = []

# после завершения итерации список list_path будет насчитывать очень много значений 
for adress, folder, file in os.walk(path):
	for i in file:
		full_path = os.path.join(adress, i)
		list_paths.append(full_path)

# создаем новый файл, указываем место куда он сохраняется.
r = open("path_to_file\\New_file1.txt", "w") # записать "w"

# Записать можно ТОЛЬКО тип данных строка. Поскольку list_path является списком, его
# необходимо проитерировать
for i in list_paths:
	r.write(i + "\n") # дополнить файл информацией, затем перевести на новую строку

r.close() # закрыть файл

# Далее считаем информацию с файла.

r = open("path_to_file\\New_file1.txt")
#information = r.readline() # в переменную сохраняется одна строка
#information = r.readlines() # в переменную создается список из строк

# можно проитерировать и создать условие отбора
for i in r:
	if "File_Name.py" in i:
		# файл с подобным название имеется на компьютере
		print(i) # OUT: path_to_file\prefix.File_Name.py
r.close() # закрыть файл

# БИНАРНЫЙ РЕЖИМ РАБОТЫ. Позволяет читать и записывать бинарные файлы.

# открыть БИНАРНЫЙ файл
r = open("path_to_file\\Example_calc.exe", "rb") # прочитать файл с бинарным режимом "rb"

# работать с бинарным файлом не можем, поэтому создадим копию БИНАРНОГО файла
y = open("path_to_file\\Copy_Example_calc.exe", "wb") # такого файла нет, поэтому он создается "wb"

while True:
	var = r.read(1048576) # побайтовое прочтение. 1024 байта 1024 раза. Это 1Мб
	# Метод .__sizeof__() позволяет посмотреть сколько оперативной памяти выделено на
	# объект
	print(var.__sizeof__())
	# файл создан, но цикл не прерывается
	# в ДАННОМ случае объект чтения занимает 33 байта (значение может отличаться)
	# создаем условие для выхода из бесконечного цикла = 33 байта
	if var.__sizeof__() == 33:
		break
	y.write(var)

print("Файл_успешно_создан")
r.close()
y.close()


# КОДИРОВКА ФАЙЛОВ.

r = open(
	"path_to_file\\New_file2.txt", "w",
	encoding="utf-8") # такого файла нет, поэтому он создается "w", кодировка utf-8
r.write("Информация снова дополнена")
r.close()

h = open(
	"path_to_file\\New_file2.txt",
	encoding="utf-8") # открываем файл, кодировка utf-8
print(h.read()) # чтение файла с выводом данных

# !!! Если файл закодирован с помощью к примеру "w", encoding="utf-16", его невозможно
# прочитать используя encoding="utf-8" !!!
