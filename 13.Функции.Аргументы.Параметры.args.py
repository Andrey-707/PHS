# Python_Hub_Studio
# Python_7_Hours

# ФУНКЦИИ
# Функция - это скрытый участок кода, в котором прописаны определенный команды.
# Этот участок кода выполняется по команде пользователя (команде запуска функции).
# Команда запуска функции может срабатывать по кнопке или по синтаксису, который указан
# в конкретной точке программы выполнить код, записаный в функции.

def show():
	# Простейшая функция выводит на экран строку
	print("Функция")

# команда вызова функции show()
show() # OUT: Функция

# Функция может вызываться сколько угодно раз и выполняется в точке запуска функции и
# обязательно после определения функции, после того, как функция записана def show():.
show() # OUT: Функция

def show2():
	x = 7
	return x

# в переменную 'y' записываем результат выполнения функции
y = show2()
print(y) # OUT: 7
z = show2() + 9
print(z) # OUT: 16

def show():
	print("Функция")
# Функция show() выполняет свои инструкции (напечатать текст), но ни чего не возвращает
# (отсутствует return), результатом вывода будет отсутствие данных.
print(show()) # OUT: None

def show2():
	x = 7
	return x

# Результатом вывода на печать переменной x будет ошибка.
# Переменные функции не видны в основном блоке программы.
print(x) # OUT: NameError: name 'x' is not defined

# И наоборот переменные основного блока программы видны в функции.
z = 3
def show3():
	x = 7 + z
	return x

print(show3()) # OUT: 10

# переменная может поменять свое значение, результат выполнения функции тоже изменится
z = 9
print(show3()) # OUT: 16


# ФУНКЦИИ. Параметры и аргументы функции.

# при помощи функции count_list() посчитать длину списка (кол-во элементов) 'some_list1'
def count_list():	
	count = 0
	for i in some_list1:
		count += 1
	return count

some_list1 = [9, 8, 7, 6]
print(count_list()) # OUT: 4

# если для других списков нужно выполнить то же самое (тоже посчитать длину списка),
# то переписывать функцию не нужно. Для этого в функции нужно задать параметр(ы).
# Параметры - это переменная, определенная только внутри функции, которая при запуске функции
# обязательно принимает значение (аргумент).
def count_list(par): # parametr
	count = 0
	for i in par:
		count += 1
	return count

some_list2 = ["a", "b", "c"]
# OUT: 3
print(count_list(some_list2)) # argument

# и так, меняя аргумент, можно посчитать длину каждого списка.
some_list1 = [9, 8, 7, 6]
print(count_list(some_list1)) # OUT: 4

some_list3 = [9, 8, 7, 6, 7, 6]
print(count_list(some_list3)) # OUT: 6

# ФУНКЦИЯ выполняется, если в неё напрямую передать аргумент, т.е. в качетсве
# аргумента задать строку. Функция посчитает её длину.
print(count_list("string")) # OUT: 6

# ФУНКЦИИ могут содержать сколько угодно параметров.
# count=0 - параметр по умолчнию.
def count_list(par, count=0): # parametr
	for i in par:
		count += 1
	return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1)) # OUT: 4

# Создадим условия для передачи двух параметров в функцию
def count_list(par, count): # parametr
	for i in par:
		count += 1
	return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1, 0)) # OUT: 4

# Если в качестве аргумента в 'count' задать значение -1, то функция возвращает индекс
# последнего элемента.
def count_list(par, count): #parametr
	for i in par:
		count += 1
	return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1, -1)) # OUT: 3

# Нельзя в начало ставить параметр по умолчанию. Такое действие приведет к ошибке.
def count_list(count=0, par): # parametr
	for i in par:
		count += 1
	return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1)) # OUT: SyntaxError: non-default argument follows default argument

# ФУНКЦИИ могут содержать сколько угодно параметров. Добавим ДВА параметра по умолчанию.
# count=0 - параметр по умолчнию (не меняет своего значения)
# par2=False - параметр по умолчнию (не меняет своего значения)
# Эта функция посчитает длину списка 'some_list1', т.к. par2=False, выполняется условие else
def count_list(par, par2=False, count=0): # parametr
	if par2 == True:
		typ = type(par[0])
		for i in par:
			count += 1
		return count, typ		
	else:
		for i in par:
			count += 1
		return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1)) # OUT: 4

# Параметр по умолчанию можно изменить во время вызова функции.
# Эта функция возвращает индекс последнего элемента.
def count_list(par, par2=False, count=0): # parametr
	if par2 == True:
		typ = type(par[0])
		for i in par:
			count += 1
		return count, typ		
	else:
		for i in par:
			count += 1
		return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1, count=-1)) # OUT: 3

# Параметр по умолчанию можно изменить во время вызова функции, при этом не обозначая его.
# Функция присваивает значения аргументов последовательно по умолчанию.
# Эта функция считает длину списка и тип данных первого элемента, который в нем
# соделжится, поскольку выполняется условие if
def count_list(par, par2=False, count=0): # parametr
	if par2 == True:
		typ = type(par[0])
		for i in par:
			count += 1
		return count, typ		
	else:
		for i in par:
			count += 1
		return count

some_list1 = [9, 8, 7, 6]
print(count_list(some_list1, True)) # OUT: (4, <class 'int'>)

# Поскольку функция возвращает кортеж, распакуем его и выведем данные на печать
a, b = count_list(some_list1, True)
print(a) # OUT: 4
print(b) # OUT: <class 'int'>


# ФУНКЦИИ. Переменное количество аргументов *args.

# для того, чтобы передать в функцию переменное количество аргументов используют 
# следующий синтаксис в виде звездочки *. Этот символ называется астери́ск (лат. звездочка).
def name(*args):
	print(args)

name(7, 8, 9, 6) # OUT: (7, 8, 9, 6)
# вызов функции без передачи аргумента не вызывает ошибку. Создается пустой кортеж.
name() # OUT: ()

# Если используется переменное количество аргументов *args и во время вызова 
# функции задать три параметра (или более), первый позиционный параметр 'h' будет принимает
# аргумент 7, а остальные аргументы упаковываются в кортеж в параметр *args.
def name(h, *args):
	print(h)
	print(args)
# OUT: 7
# 	   (8, 9, 5)
name(7, 8, 9, 5)

# число 3 упаковывается в кортеж и передается в параметр *args
def name(h, g, *args): #parametr
	print(h)
	print(g)
	print(args)
# OUT: 7
#      8
#      (3,)
name(7, 8, 3)

# Если параметры 'h' и 'g' имют значения по умолчанию, то всё равно аргументы 
# пойдут по параметрам 'h' и 'g' соответственно, а третий аргумент упакуется в кортеж.
def name(h=1, g=2, *args): #parametr
	print(h)
	print(g)
	print(args)
# OUT: 7
#      8
#      (3,)
name(7, 8, 3)

# Если после параметра *args указать ключевае параметры, вызов функции вызовет ошибку.
# В данном случае (3, 4, 5, 6) относится к параметру *args
def name(h=1, g=2, *args, key):
	print(h)
	print(g)
	print(args)

name(7, 8, 3, 4, 5, 6) # OUT: TypeError: name() missing 1 required keyword-only argument: 'key'

# В данном случае ошибки не будет
def name(h=1, g=2, *args, key=1):
	print(h)
	print(g)
	print(args)
	print(key)		
# OUT: 7
#      8
#      (3, 4, 5, 6)
#      1
name(7, 8, 3, 4, 5, 6)

# Для присвоения значения ключевому параметру 'key', к нему нужно обратитьсья по имени 'key'
def name(h=1, g=2, *args, key):
	print(h)
	print(g)
	print(args)
	print(key)	
# OUT: 7
#      8
#      (3, 4, 5, 6)
#      1
name(7, 8, 3, 4, 5, 6, key=1)

# Создадим функцию-алгоритм, которая принимает в качетсве аргументов списки и добавляет
# их элементы в новый список. При этом повторяющиеся значения отсеиваются.
# Число 5 добавится в список 1 раз. Обнаружено повторений 2.
def exclusive_item(*args):
    '''Функция принимает переменное количество итерируемых объектов (списков/кортежей),
    возвращает список с уникальными элементами всех объектов, переданных в качестве
    аргументов'''
    # список эксклюзивных элементов
    new_list = []
    # переменная-счетчик
    # фиксирует повторение элемента
    count = 0
    # итерация по переменной i (в нашем случае по спискам/кортежам)
    for i in args:
        # итерация по переменной j (в нашем случае по элементам списка/кортежа i)
        for j in i:
            # условие: если переменная j (элемент j списка/кортежа i) не в списке new_list
            if j not in new_list:
                # при сробатывании условия добавляет переменную j (элемент списка/кортежа)
                # в список new_list
                new_list.append(j)
            else:
                # элемент повторяется, переменная-счетчик увеличена на +1
                count += 1
    print("Обнаружено повторений:", count)
    # возвращает список эксклюзивных элементов
    return new_list


# в качестве аргументов используем списки
some_list1 = [1, 2, 3, 4, 5]
some_list2 = [9, 8, 7, 6, 5]
some_list3 = ["a", "b", "c", "d", 5]

# в переменную 'l' передаются данные выполнения функции
l = exclusive_item(some_list1, some_list2, some_list3)
# OUT: Обнаружено повторений: 2
#      [1, 2, 3, 4, 5, 9, 8, 7, 6, 'a', 'b', 'c', 'd']
print(l)

# в качестве аргументов используем кортежи
some_lis1 = 1, 2, 3, 4, 5
some_lis2 = 9, 8, 7, 6, 5
some_lis3 = "a", "b", "c", "d", 5

# в переменную 't' передаются данные выполнения функции и оботачиваются в функцию tuple() чтобы
# получить в результате кортеж уникальных элементов
t = tuple(exclusive_item(some_lis1, some_lis2, some_lis3))
# OUT: Обнаружено повторений: 2
#      (1, 2, 3, 4, 5, 9, 8, 7, 6, 'a', 'b', 'c', 'd')
print(t)

# Добавим аргумент key=False, если в него передать параметр False, список отсортируется.
# Если список содержит буквы some_list3 = ["a", "b", "c", "d", 5], то произойдет ошибка
# TypeError: '<' not supported between instances of 'str' and 'int'
def exclusive_item(*args, key=False):
    # список эксклюзивных элементов
    new_list = []
    # итерация по переменной i (в нашем случае по спискам/кортежам)
    for i in args:
        # итерация по переменной j (в нашем случае по элементам списка/кортежа i)
        for j in i:
            # условие: если переменная j (элемент j списка/кортежа i) не в списке new_list
            if j not in new_list:
                # при сробатывании условия добавляет переменную j (элемент списка/кортежа)
                # в список new_list
                new_list.append(j)
    if key == True:
        new_list.sort()
    # возвращает список эксклюзивных элементов
    return new_list


some_list1 = [1, 2, 3, 4, 5]
some_list2 = [9, 8, 7, 6, 5]
some_list3 = ["a", "b", "c", "d", 5]

# в переменную 'x' передаются данные выполнения функции, такая сортировка не возможна
x = exclusive_item(some_list1, some_list2, some_list3, key=True) #argument
print(x)# OUT: TypeError: '<' not supported between instances of 'str' and 'int'

# Добавим аргумент key=False, если в него передать параметр False, список отсортируется.
# Передаем в функцию списки, которые содержат ТОЛЬКО числа (<class 'int'>)
def exclusive_item(*args, key=False):
    # список эксклюзивных элементов
    new_list = []
    # итерация по переменной i (в нашем случае по спискам/кортежам)
    for i in args:
        # итерация по переменной j (в нашем случае по элементам списка/кортежа i)
        for j in i:
            # условие: если переменная j (элемент j списка/кортежа i) не в списке new_list
            if j not in new_list:
                # при сробатывании условия добавляет переменную j (элемент списка/кортежа)
                # в список new_list
                new_list.append(j)
    if key == True:
        new_list.sort()
    # возвращает список эксклюзивных элементов
    return new_list

some_list1 = [1, 2, 3, 4, 5]
some_list2 = [9, 8, 7, 6, 5]
some_list3 = 3, 3, 4, 10, 5

# в переменную x передаются данные выполнения функции
x = exclusive_item(some_list1, some_list2, some_list3, key=True)
print(x) # OUT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
