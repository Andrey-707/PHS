# Python_Hub_Studio
# Python_7_Hours

# ДЕКОРАТОРЫ @
# ДЕКОРАТОР - это функция, которая позволяет обернуть другую функцию в свой код, тем самым модифицировав её поведение.
# --------------------------------------STEP_1------------------------------------------------------------------------
def make():
    enter = input("Enter something...")
    print(enter)

# обычный вызов функции
make()
# т.к. функция является объектом в python можно создать переменную-идентификатор и присвоить ссылку на функцию
h = make
# и запустить функцию make() вызвав переменную-идентификатор
h()

# --------------------------------------STEP_2------------------------------------------------------------------------
# ЗАДАЧА. Сохранить обращение к функции make() по её же имени, но обернуть её код в другую функцию.

def decor(f):
    print("Код декоратора")
    f()
    print("Код декоратора 2")

# @decor - это особый синтаксис. 
# @decor # make = decor(make) В make присваивается запуск функции-декоратора decor(), в который передается имя
# функции make.

# Синтаксис декорирования функции. Если запускать код, он срабатывает без вызова функции make() 
@decor # make = decor(make)
def make():
    enter = input("Enter something...")
    print(enter)

# Сделаем запуск функции make(). Это приведе к ошибке (объект не вызываемый).
# TypeError: 'NoneType' object is not callable
make()

# --------------------------------------STEP_3------------------------------------------------------------------------
# Чтобы избежать ошибки при вызове функции make(), функции-декоратору нужно дать обертку.
def decor(f):
    def wrapper(): # функция-обертка
        print("Код декоратора")
        f()
        print("Второй код декоратора")
    return wrapper

@decor # make = decor(make)
def make():
    enter = input("Enter something...")
    print(enter)

# вызов функции make() происходит без ошибок.
print("Запуск функции здесь")    
make()

# --------------------------------------STEP_4------------------------------------------------------------------------
# Если в ходе запуска функции make() или make2() происходит ошибка, её можно обрабатывать в декораторе. К примеру,
# если на запрос программы "Введите число", пользователь вводит вместо типы данных float тип данных str
# Для этого внутри функции-декоратора создаем переменную к примеру h, в которую присваиваем (сохраняем) возвращаемое 
# значение после обработки исключений и далее выводим её return h

def decor(f):
    def wrapper(): # функция-обертка
        try:
            print("Код декоратора")
            h = f()
            print("Второй код декоратора")
        except Exception:
            print("Повторите ввод")
            h = f()
        return h
    return wrapper

@decor # make = decor(make)
def make():
    enter = float(input("Введите число: "))
    print(enter)

@decor
def make2():
    enter = input("Введите число ещё раз")
    print(enter)

# если после обработки исклчения повторно ввести тип данных str, программа вылетит с ошибкой
# ValueError: could not convert string to float:
make()
make2()
