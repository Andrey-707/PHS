# Python_Hub_Studio
# Python_7_Hours

# ИМПОРТ МОДУЛЕЙ.

# адрес хранения модулей python: D:\Python\Lib

# !!!Запускать файл test.py, который импортирует модуль необходимо, когда ОБА ФАЙЛА ХРАНЯТСЯ В ОДНОЙ ПАПКЕ!!!

# функция dir() позволяет посмотреть какие имена нам доступны
# если запустить python и в поле ввода набрать dir()
# вывод: >>> dir()
#        ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']

# можно добавить к списку имен переменную. Добавим x
x = "Andrey"
print(dir())
# вывод: >>> dir()
#        ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__',
#         '__spec__', 'x']

# Импортируем модуль Newmod. Его адрес D:\Python\Test\Python_Lessons\Python_Hub_Studio\25.Импорт_модулей

import Newmod


# OUT: ['Newmod', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__',
#       '__name__', '__package__', '__spec__', 'x']
print(dir())

# Далее после импорта модуля появляется возможность брать измодуля какую-либо функцию или переменную.
# функция dir() также позволяет посмотреть содержимое модуля

# OUT:['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__',
#      '__spec__', 'k', 'k2', 'newf']
print(dir(Newmod))

# вызов справки по модулю. Функция help()
# ПРИ ВЫЗОВЕ ИЗ КОМАНДНОЙ СТРОКИ РАБОТАЕТ ТОЛЬКО С ЛАТИНИЦЕЙ
# Если ввести в командной строке "chcp 1251", то работает и с кириллицей.   <---  Замена кодировки.
# ПРИ ВЫЗОВЕ ИЗ pycharm РАБОТАЕТ С КИРИЛЛИЦЕЙ
print(help(Newmod))

# вызов справки по конкретной функции. Вызов строки-документации функции.
print(help(Newmod.newf))

# передача значения "3" в функцию, которая импортирована из модуля
print(Newmod.newf(3)) # OUT: 9

# вызов значения из переменных k1 и k2 в модуле
print(Newmod.k1) # OUT: 7
print(Newmod.k2) # OUT: ['list', 'from', 'strings']


# импортировать конкретный элемент из модуля
# в этом случае импортируется ВСЕ элементы модуля:
from Newmod import *


# после такого способа импортирования модуля можно вызывать элементы по их названию
# вывод: 7
print(k1)
# вывод: ['list', 'from', 'strings']
print(k2)

# можно импортировать отдельный элемент модуля. Например, функцию def newf(par):
from Newmod import newf


print(newf(7)) # OUT: 49


# ВСТРОЕННЫЕ МОДУЛИ. Модуль sys
import sys


# список адресов, по которым питон будет искать модуль, который пользователь хочет импортировать
# OUT: ['D:\\Python\\Test', 'D:\\Python\\python38.zip', 'D:\\Python\\DLLs', 'D:\\Python\\lib',
#       'D:\\Python', 'D:\\Python\\lib\\site-packages']
print(sys.path)


# Если импортировать из модуля все элементы
from  import *


# OUT:['D:\\Python\\Test', 'D:\\Python\\python38.zip', 'D:\\Python\\DLLs', 'D:\\Python\\lib',
#      'D:\\Python', 'D:\\Python\\lib\\site-packages']
print(path)

# а затем ввести переменную и присвоить ей значение, то вызов к примеру path перестает работать
path = "Andrey"
print(path) # OUT: Andrey


# Поэтому рекомендуется импортировать модуль и вызывать данные через имя модуля. Например sys.path
# Данный способ исключает возможность путаницы с именами.
import sys


path = "Andrey"
print(path) # OUT: Andrey
# OUT:['D:\\Python\\Test', 'D:\\Python\\python38.zip', 'D:\\Python\\DLLs', 'D:\\Python\\lib',
#      'D:\\Python', 'D:\\Python\\lib\\site-packages']
print(sys.path)


# В случае когда имя модуля длинное, ему можно присвоить псевдоним и в дальнейшем использовать его
import Newmod as NM


print(N.k1) # OUT: 7
print(N.k2) # OUT: ['list', 'from', 'strings']


# ЧТО ТАКОЕ <<<if __name__ == "__main__": >>>?

# Если в модуле содержится какой-то функционал (к примеру в моем модуле Newmod прописан запуск функции)
# print(newf(int(input("Введите число: "))))
# и далее если ПРОСТО импортировать модуль в файл test.py и запустить этот файл, то выполняется 
# функционал импортированного модуля Newmod, т.е. происходит запуск функции.
import Newmod


# существует проверка <<<if __name__ == "__main__": >>>, которая
# позволяет запускать функцию (или выполнять любой другой функционал) если имя принимает значение __main__

# когда пользователь запускает модуль (к примеру нажать CTRL+B через sublime_text_3), python присваивает
# __name__ значение __main__

# если модуль импортируется и далее есть запись if __name__ == "__main__":, то мы можем его импортировать
# и его код исполнен не будет, потому что его имя уже не __main__
# Имеется в виду, что будет выполнен запрос через input(), функция не примет число newf(7)


# Откроем test.py, импортируем модуль. В данном случае __name__ == Newmod
import Newmod


print(Newmod.__name__ ) # имя Newmod


# Т.к. в нашем модуле Newmod (можно открыть файл на чтение и проверить) прописана проверка
# <<<if __name__ == "__main__": >>>, то мы можем импортировать модуль и запусть функционал после ипорта
print(Newmod.newf(7)) # OUT: 49

# если зайти в модуль Newmod (открыть) и закоментировать строку <<<if __name__ == "__main__": >>>, а затем
# повторить вызов функционала, мы увидим следующее (программа запросит данные через input())
print(Newmod.newf(7)) # OUT: Введите число:
